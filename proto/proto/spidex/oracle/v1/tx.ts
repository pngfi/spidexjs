// @ts-nocheck
/* eslint-disable */
/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.21.7
 * source: spidex/oracle/v1/tx.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_2 from "../../../cosmos/base/v1beta1/coin";
import * as pb_1 from "google-protobuf";
export namespace pngfi.spidex.oracle.v1 {
    export class MsgCoinRatesData extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            creator?: string;
            ask_count?: number;
            min_count?: number;
            fee_limit?: dependency_2.cosmos.base.v1beta1.Coin[];
            prepare_gas?: number;
            execute_gas?: number;
            client_id?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [4], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("creator" in data && data.creator != undefined) {
                    this.creator = data.creator;
                }
                if ("ask_count" in data && data.ask_count != undefined) {
                    this.ask_count = data.ask_count;
                }
                if ("min_count" in data && data.min_count != undefined) {
                    this.min_count = data.min_count;
                }
                if ("fee_limit" in data && data.fee_limit != undefined) {
                    this.fee_limit = data.fee_limit;
                }
                if ("prepare_gas" in data && data.prepare_gas != undefined) {
                    this.prepare_gas = data.prepare_gas;
                }
                if ("execute_gas" in data && data.execute_gas != undefined) {
                    this.execute_gas = data.execute_gas;
                }
                if ("client_id" in data && data.client_id != undefined) {
                    this.client_id = data.client_id;
                }
            }
        }
        get creator() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set creator(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get ask_count() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set ask_count(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get min_count() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set min_count(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get fee_limit() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_2.cosmos.base.v1beta1.Coin, 4) as dependency_2.cosmos.base.v1beta1.Coin[];
        }
        set fee_limit(value: dependency_2.cosmos.base.v1beta1.Coin[]) {
            pb_1.Message.setRepeatedWrapperField(this, 4, value);
        }
        get prepare_gas() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set prepare_gas(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get execute_gas() {
            return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
        }
        set execute_gas(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        get client_id() {
            return pb_1.Message.getFieldWithDefault(this, 7, "") as string;
        }
        set client_id(value: string) {
            pb_1.Message.setField(this, 7, value);
        }
        static fromObject(data: {
            creator?: string;
            ask_count?: number;
            min_count?: number;
            fee_limit?: ReturnType<typeof dependency_2.cosmos.base.v1beta1.Coin.prototype.toObject>[];
            prepare_gas?: number;
            execute_gas?: number;
            client_id?: string;
        }): MsgCoinRatesData {
            const message = new MsgCoinRatesData({});
            if (data.creator != null) {
                message.creator = data.creator;
            }
            if (data.ask_count != null) {
                message.ask_count = data.ask_count;
            }
            if (data.min_count != null) {
                message.min_count = data.min_count;
            }
            if (data.fee_limit != null) {
                message.fee_limit = data.fee_limit.map(item => dependency_2.cosmos.base.v1beta1.Coin.fromObject(item));
            }
            if (data.prepare_gas != null) {
                message.prepare_gas = data.prepare_gas;
            }
            if (data.execute_gas != null) {
                message.execute_gas = data.execute_gas;
            }
            if (data.client_id != null) {
                message.client_id = data.client_id;
            }
            return message;
        }
        toObject() {
            const data: {
                creator?: string;
                ask_count?: number;
                min_count?: number;
                fee_limit?: ReturnType<typeof dependency_2.cosmos.base.v1beta1.Coin.prototype.toObject>[];
                prepare_gas?: number;
                execute_gas?: number;
                client_id?: string;
            } = {};
            if (this.creator != null) {
                data.creator = this.creator;
            }
            if (this.ask_count != null) {
                data.ask_count = this.ask_count;
            }
            if (this.min_count != null) {
                data.min_count = this.min_count;
            }
            if (this.fee_limit != null) {
                data.fee_limit = this.fee_limit.map((item: dependency_2.cosmos.base.v1beta1.Coin) => item.toObject());
            }
            if (this.prepare_gas != null) {
                data.prepare_gas = this.prepare_gas;
            }
            if (this.execute_gas != null) {
                data.execute_gas = this.execute_gas;
            }
            if (this.client_id != null) {
                data.client_id = this.client_id;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.creator.length)
                writer.writeString(1, this.creator);
            if (this.ask_count != 0)
                writer.writeUint64(2, this.ask_count);
            if (this.min_count != 0)
                writer.writeUint64(3, this.min_count);
            if (this.fee_limit.length)
                writer.writeRepeatedMessage(4, this.fee_limit, (item: dependency_2.cosmos.base.v1beta1.Coin) => item.serialize(writer));
            if (this.prepare_gas != 0)
                writer.writeUint64(5, this.prepare_gas);
            if (this.execute_gas != 0)
                writer.writeUint64(6, this.execute_gas);
            if (this.client_id.length)
                writer.writeString(7, this.client_id);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgCoinRatesData {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgCoinRatesData();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.creator = reader.readString();
                        break;
                    case 2:
                        message.ask_count = reader.readUint64();
                        break;
                    case 3:
                        message.min_count = reader.readUint64();
                        break;
                    case 4:
                        reader.readMessage(message.fee_limit, () => pb_1.Message.addToRepeatedWrapperField(message, 4, dependency_2.cosmos.base.v1beta1.Coin.deserialize(reader), dependency_2.cosmos.base.v1beta1.Coin));
                        break;
                    case 5:
                        message.prepare_gas = reader.readUint64();
                        break;
                    case 6:
                        message.execute_gas = reader.readUint64();
                        break;
                    case 7:
                        message.client_id = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgCoinRatesData {
            return MsgCoinRatesData.deserialize(bytes);
        }
    }
    export class MsgCoinRatesDataResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): MsgCoinRatesDataResponse {
            const message = new MsgCoinRatesDataResponse({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgCoinRatesDataResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgCoinRatesDataResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgCoinRatesDataResponse {
            return MsgCoinRatesDataResponse.deserialize(bytes);
        }
    }
    export class MsgCreateCoinSymbol extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            creator?: string;
            symbol?: string;
            id?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("creator" in data && data.creator != undefined) {
                    this.creator = data.creator;
                }
                if ("symbol" in data && data.symbol != undefined) {
                    this.symbol = data.symbol;
                }
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
            }
        }
        get creator() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set creator(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get symbol() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set symbol(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get id() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set id(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            creator?: string;
            symbol?: string;
            id?: number;
        }): MsgCreateCoinSymbol {
            const message = new MsgCreateCoinSymbol({});
            if (data.creator != null) {
                message.creator = data.creator;
            }
            if (data.symbol != null) {
                message.symbol = data.symbol;
            }
            if (data.id != null) {
                message.id = data.id;
            }
            return message;
        }
        toObject() {
            const data: {
                creator?: string;
                symbol?: string;
                id?: number;
            } = {};
            if (this.creator != null) {
                data.creator = this.creator;
            }
            if (this.symbol != null) {
                data.symbol = this.symbol;
            }
            if (this.id != null) {
                data.id = this.id;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.creator.length)
                writer.writeString(1, this.creator);
            if (this.symbol.length)
                writer.writeString(2, this.symbol);
            if (this.id != 0)
                writer.writeUint64(3, this.id);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgCreateCoinSymbol {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgCreateCoinSymbol();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.creator = reader.readString();
                        break;
                    case 2:
                        message.symbol = reader.readString();
                        break;
                    case 3:
                        message.id = reader.readUint64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgCreateCoinSymbol {
            return MsgCreateCoinSymbol.deserialize(bytes);
        }
    }
    export class MsgCreateCoinSymbolResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            id?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
            }
        }
        get id() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set id(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            id?: number;
        }): MsgCreateCoinSymbolResponse {
            const message = new MsgCreateCoinSymbolResponse({});
            if (data.id != null) {
                message.id = data.id;
            }
            return message;
        }
        toObject() {
            const data: {
                id?: number;
            } = {};
            if (this.id != null) {
                data.id = this.id;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.id != 0)
                writer.writeUint64(1, this.id);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgCreateCoinSymbolResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgCreateCoinSymbolResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.id = reader.readUint64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgCreateCoinSymbolResponse {
            return MsgCreateCoinSymbolResponse.deserialize(bytes);
        }
    }
    export class MsgUpdateCoinSymbol extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            creator?: string;
            id?: number;
            symbol?: string;
            isDelete?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("creator" in data && data.creator != undefined) {
                    this.creator = data.creator;
                }
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
                if ("symbol" in data && data.symbol != undefined) {
                    this.symbol = data.symbol;
                }
                if ("isDelete" in data && data.isDelete != undefined) {
                    this.isDelete = data.isDelete;
                }
            }
        }
        get creator() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set creator(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get id() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set id(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get symbol() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set symbol(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get isDelete() {
            return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
        }
        set isDelete(value: boolean) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            creator?: string;
            id?: number;
            symbol?: string;
            isDelete?: boolean;
        }): MsgUpdateCoinSymbol {
            const message = new MsgUpdateCoinSymbol({});
            if (data.creator != null) {
                message.creator = data.creator;
            }
            if (data.id != null) {
                message.id = data.id;
            }
            if (data.symbol != null) {
                message.symbol = data.symbol;
            }
            if (data.isDelete != null) {
                message.isDelete = data.isDelete;
            }
            return message;
        }
        toObject() {
            const data: {
                creator?: string;
                id?: number;
                symbol?: string;
                isDelete?: boolean;
            } = {};
            if (this.creator != null) {
                data.creator = this.creator;
            }
            if (this.id != null) {
                data.id = this.id;
            }
            if (this.symbol != null) {
                data.symbol = this.symbol;
            }
            if (this.isDelete != null) {
                data.isDelete = this.isDelete;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.creator.length)
                writer.writeString(1, this.creator);
            if (this.id != 0)
                writer.writeUint64(2, this.id);
            if (this.symbol.length)
                writer.writeString(3, this.symbol);
            if (this.isDelete != false)
                writer.writeBool(4, this.isDelete);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgUpdateCoinSymbol {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgUpdateCoinSymbol();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.creator = reader.readString();
                        break;
                    case 2:
                        message.id = reader.readUint64();
                        break;
                    case 3:
                        message.symbol = reader.readString();
                        break;
                    case 4:
                        message.isDelete = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgUpdateCoinSymbol {
            return MsgUpdateCoinSymbol.deserialize(bytes);
        }
    }
    export class MsgUpdateCoinSymbolResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): MsgUpdateCoinSymbolResponse {
            const message = new MsgUpdateCoinSymbolResponse({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgUpdateCoinSymbolResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgUpdateCoinSymbolResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgUpdateCoinSymbolResponse {
            return MsgUpdateCoinSymbolResponse.deserialize(bytes);
        }
    }
    export class MsgUpdateAdmin extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            creator?: string;
            newAdmin?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("creator" in data && data.creator != undefined) {
                    this.creator = data.creator;
                }
                if ("newAdmin" in data && data.newAdmin != undefined) {
                    this.newAdmin = data.newAdmin;
                }
            }
        }
        get creator() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set creator(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get newAdmin() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set newAdmin(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            creator?: string;
            newAdmin?: string;
        }): MsgUpdateAdmin {
            const message = new MsgUpdateAdmin({});
            if (data.creator != null) {
                message.creator = data.creator;
            }
            if (data.newAdmin != null) {
                message.newAdmin = data.newAdmin;
            }
            return message;
        }
        toObject() {
            const data: {
                creator?: string;
                newAdmin?: string;
            } = {};
            if (this.creator != null) {
                data.creator = this.creator;
            }
            if (this.newAdmin != null) {
                data.newAdmin = this.newAdmin;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.creator.length)
                writer.writeString(1, this.creator);
            if (this.newAdmin.length)
                writer.writeString(2, this.newAdmin);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgUpdateAdmin {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgUpdateAdmin();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.creator = reader.readString();
                        break;
                    case 2:
                        message.newAdmin = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgUpdateAdmin {
            return MsgUpdateAdmin.deserialize(bytes);
        }
    }
    export class MsgUpdateAdminResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): MsgUpdateAdminResponse {
            const message = new MsgUpdateAdminResponse({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgUpdateAdminResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgUpdateAdminResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgUpdateAdminResponse {
            return MsgUpdateAdminResponse.deserialize(bytes);
        }
    }
    export class MsgUpdateChannel extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            creator?: string;
            newChannel?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("creator" in data && data.creator != undefined) {
                    this.creator = data.creator;
                }
                if ("newChannel" in data && data.newChannel != undefined) {
                    this.newChannel = data.newChannel;
                }
            }
        }
        get creator() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set creator(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get newChannel() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set newChannel(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            creator?: string;
            newChannel?: string;
        }): MsgUpdateChannel {
            const message = new MsgUpdateChannel({});
            if (data.creator != null) {
                message.creator = data.creator;
            }
            if (data.newChannel != null) {
                message.newChannel = data.newChannel;
            }
            return message;
        }
        toObject() {
            const data: {
                creator?: string;
                newChannel?: string;
            } = {};
            if (this.creator != null) {
                data.creator = this.creator;
            }
            if (this.newChannel != null) {
                data.newChannel = this.newChannel;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.creator.length)
                writer.writeString(1, this.creator);
            if (this.newChannel.length)
                writer.writeString(2, this.newChannel);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgUpdateChannel {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgUpdateChannel();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.creator = reader.readString();
                        break;
                    case 2:
                        message.newChannel = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgUpdateChannel {
            return MsgUpdateChannel.deserialize(bytes);
        }
    }
    export class MsgUpdateChannelResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): MsgUpdateChannelResponse {
            const message = new MsgUpdateChannelResponse({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgUpdateChannelResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgUpdateChannelResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgUpdateChannelResponse {
            return MsgUpdateChannelResponse.deserialize(bytes);
        }
    }
    export class MsgUpdateScriptId extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            creator?: string;
            newScriptId?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("creator" in data && data.creator != undefined) {
                    this.creator = data.creator;
                }
                if ("newScriptId" in data && data.newScriptId != undefined) {
                    this.newScriptId = data.newScriptId;
                }
            }
        }
        get creator() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set creator(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get newScriptId() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set newScriptId(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            creator?: string;
            newScriptId?: number;
        }): MsgUpdateScriptId {
            const message = new MsgUpdateScriptId({});
            if (data.creator != null) {
                message.creator = data.creator;
            }
            if (data.newScriptId != null) {
                message.newScriptId = data.newScriptId;
            }
            return message;
        }
        toObject() {
            const data: {
                creator?: string;
                newScriptId?: number;
            } = {};
            if (this.creator != null) {
                data.creator = this.creator;
            }
            if (this.newScriptId != null) {
                data.newScriptId = this.newScriptId;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.creator.length)
                writer.writeString(1, this.creator);
            if (this.newScriptId != 0)
                writer.writeUint64(2, this.newScriptId);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgUpdateScriptId {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgUpdateScriptId();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.creator = reader.readString();
                        break;
                    case 2:
                        message.newScriptId = reader.readUint64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgUpdateScriptId {
            return MsgUpdateScriptId.deserialize(bytes);
        }
    }
    export class MsgUpdateScriptIdResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): MsgUpdateScriptIdResponse {
            const message = new MsgUpdateScriptIdResponse({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgUpdateScriptIdResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgUpdateScriptIdResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgUpdateScriptIdResponse {
            return MsgUpdateScriptIdResponse.deserialize(bytes);
        }
    }
    export class MsgUpdateMultiplier extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            creator?: string;
            newMultiplier?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("creator" in data && data.creator != undefined) {
                    this.creator = data.creator;
                }
                if ("newMultiplier" in data && data.newMultiplier != undefined) {
                    this.newMultiplier = data.newMultiplier;
                }
            }
        }
        get creator() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set creator(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get newMultiplier() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set newMultiplier(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            creator?: string;
            newMultiplier?: number;
        }): MsgUpdateMultiplier {
            const message = new MsgUpdateMultiplier({});
            if (data.creator != null) {
                message.creator = data.creator;
            }
            if (data.newMultiplier != null) {
                message.newMultiplier = data.newMultiplier;
            }
            return message;
        }
        toObject() {
            const data: {
                creator?: string;
                newMultiplier?: number;
            } = {};
            if (this.creator != null) {
                data.creator = this.creator;
            }
            if (this.newMultiplier != null) {
                data.newMultiplier = this.newMultiplier;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.creator.length)
                writer.writeString(1, this.creator);
            if (this.newMultiplier != 0)
                writer.writeUint64(2, this.newMultiplier);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgUpdateMultiplier {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgUpdateMultiplier();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.creator = reader.readString();
                        break;
                    case 2:
                        message.newMultiplier = reader.readUint64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgUpdateMultiplier {
            return MsgUpdateMultiplier.deserialize(bytes);
        }
    }
    export class MsgUpdateMultiplierResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): MsgUpdateMultiplierResponse {
            const message = new MsgUpdateMultiplierResponse({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgUpdateMultiplierResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgUpdateMultiplierResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgUpdateMultiplierResponse {
            return MsgUpdateMultiplierResponse.deserialize(bytes);
        }
    }
}
